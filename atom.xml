<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LINJING BI</title>
  
  <subtitle>biubiubiu...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-06T09:17:16.382Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Bi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python多线程编程</title>
    <link href="http://yoursite.com/2018/12/06/python-multiplexing/"/>
    <id>http://yoursite.com/2018/12/06/python-multiplexing/</id>
    <published>2018-12-06T02:54:59.000Z</published>
    <updated>2018-12-06T09:17:16.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python的threading模块"><a href="#python的threading模块" class="headerlink" title="python的threading模块"></a>python的threading模块</h2><h3 id="一、线程"><a href="#一、线程" class="headerlink" title="一、线程"></a>一、线程</h3><p>线程是操作系统能够进行运算调度的最小单位。线程被包含在进程中，是进程中实际处理单位。<br>一条线程是指进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><h3 id="二、进程"><a href="#二、进程" class="headerlink" title="二、进程"></a>二、进程</h3><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><h3 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h3><p>进程是一块包含了某些资源的内存区域。操作系统利用进程把它的工作划分为一些功能单元。<br>进程中所包含的一个或多个执行单元成为线程。进程还拥有一个私有的虚拟地址空间，该进程空间仅能被它所包含的线程访问。<br>线程只能归属于一个进程并且它只能访问该进程所拥有的资源，一个进程下的所有线程共享该进程的资源。当操作系统创建一个进程后，该进程自动申请一个名为主线程或首要线程的线程。<br>处理计算密集型任务或函数用<strong>进程</strong><br>处理IO密集型任务或函数用<strong>线程</strong>  </p><h3 id="四、GIL"><a href="#四、GIL" class="headerlink" title="四、GIL"></a>四、GIL</h3><p>首先，GIL并不是Python的特性，它是在实现Python解析器（CPython）时所引入的一个概念。<br>同一段代码可以在CPython，PyPy，Psyco等不同的Python执行环境中运行，其中PyPy就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境，所以CPython的GIL缺陷也就约等在了Python身上。<br>GIL特性：<br>    python中的一个线程对应于c语言中的一个线程（CPython）<br>    GIL使得同一时刻只有一个线程在CPU上执行字节代码，无法将多个线程映射到多个CPU上去执行。<br>    也就是说 <strong>在同一时刻，只有一个线程进入CPython解释器</strong><br>解决GIL限制的办法：  </p><pre><code>1. 多进程编程：既然多线程不能同时进入CPython解释器，我们可以通过把多个线程放入不同进程中，让多进程进入CPython解释器，分配给各个CPU，以利用多核实现并行。  2. 协程：后面会讲到</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;python的threading模块&quot;&gt;&lt;a href=&quot;#python的threading模块&quot; class=&quot;headerlink&quot; title=&quot;python的threading模块&quot;&gt;&lt;/a&gt;python的threading模块&lt;/h2&gt;&lt;h3 id=&quot;一
      
    
    </summary>
    
      <category term="python多线程编程" scheme="http://yoursite.com/categories/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Socket网络编程-Notebook</title>
    <link href="http://yoursite.com/2018/12/02/socket-start-notebook/"/>
    <id>http://yoursite.com/2018/12/02/socket-start-notebook/</id>
    <published>2018-12-02T02:39:30.000Z</published>
    <updated>2018-12-02T04:14:37.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>socket通常也称作套接字，用于描述IP地址和端口，用于连接应用层与传输层。  </p><p>socket网络编程流程见下图：<br><img src="https://raw.githubusercontent.com/LinjingBi/Hexo-images/master/socket.PNG" alt="socket1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Socket&quot;&gt;&lt;a href=&quot;#Socket&quot; class=&quot;headerlink&quot; title=&quot;Socket&quot;&gt;&lt;/a&gt;Socket&lt;/h1&gt;&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一
      
    
    </summary>
    
      <category term="socket网络编程" scheme="http://yoursite.com/categories/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="socket" scheme="http://yoursite.com/tags/socket/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 58 最后一个单词的长度</title>
    <link href="http://yoursite.com/2018/11/20/leetcode-58/"/>
    <id>http://yoursite.com/2018/11/20/leetcode-58/</id>
    <published>2018-11-20T14:41:41.000Z</published>
    <updated>2018-11-20T15:00:53.673Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><pre><code>给定一个仅包含大小写字母和空格&apos; &apos;的字符串，返回其最后一个单词的长度。如果不存在返回0例子：输入：&apos;Hello World’输出：5</code></pre><p>这个例子用python的str.split()很简单，只是想强调一下，当str为空或者全是’ ‘时，得到的列表也为空，此时不能用[-1]找最后一个元素。还有，如果a不为空或者全’ ‘，而是一个单一字符组成的字符串，a.split(‘该单一字符’)得到的列表为[‘’ for i in range(len(a)+1)]，而不是一个空列表。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        b = s.split()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> len(b) == <span class="number">0</span> <span class="keyword">else</span> len(b[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;给定一个仅包含大小写字母和空格&amp;apos; &amp;apos;的字符串，返回其最后一个单词的长度。如果不存在返回0
例子：
输入：&amp;apos;Hello World’
输出：5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个例子用python的str.split()很简单，只是想强调一下，当str为空或者全是’ ‘时，得到的列表也为空，此时不能用[-1]找最后一个元素。还有，如果a不为空或者全’ ‘，而是一个单一字符组成的字符串，a.split(‘该单一字符’)得到的列表为[‘’ for i in range(len(a)+1)]，而不是一个空列表。&lt;br&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="easy" scheme="http://yoursite.com/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 6 ZigZag变换</title>
    <link href="http://yoursite.com/2018/11/20/leetcode-6/"/>
    <id>http://yoursite.com/2018/11/20/leetcode-6/</id>
    <published>2018-11-20T13:52:08.000Z</published>
    <updated>2018-11-20T14:09:34.655Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><pre><code>将字符串’PAYPALISHIRING&apos;以Z字型排列成给定的行数，然后逐行读取字符：例子：行数为3P  A   H   NA P L S I I GY    I   R输出：&apos;PAHNAPLSIIGYIR&apos;</code></pre><p>例如第二行的，P L，他们是字符串的第3，5，此时row是2x3-2=4，那么可以看出 3 % 4 = 3， 5 % 4 = 1，3 + 1 = 4 = 2 <em> numrows -2 。他们都属于a[1],所以可以用2</em>numRows - 2 - row，来求出3的行数。<br><a id="more"></a> </p><pre><code class="python"><span class="comment">#python3</span><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s, numRows)</span>:</span>        <span class="string">"""</span><span class="string">        :type s: str</span><span class="string">        :type numRows: int</span><span class="string">        :rtype: str</span><span class="string">        """</span>        <span class="keyword">if</span> numRows == <span class="number">1</span>:            <span class="keyword">return</span> s        a = [<span class="string">''</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(numRows)] <span class="comment">#建立一个numrows的数组，用来存放每一行</span>        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):            row = i % (<span class="number">2</span>*numRows - <span class="number">2</span>)            <span class="keyword">if</span> row &gt;= numRows:                row = <span class="number">2</span>*numRows - <span class="number">2</span> - row <span class="comment">#！！！</span>            a[row] += s[i]        <span class="keyword">return</span> <span class="string">''</span>.join(a) <span class="comment">#a=[PAHN,APLSIIG,YIR]</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;将字符串’PAYPALISHIRING&amp;apos;以Z字型排列成给定的行数，然后逐行读取字符：
例子：
行数为3
P  A   H   N
A P L S I I G
Y    I   R
输出：
&amp;apos;PAHNAPLSIIGYIR&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如第二行的，P L，他们是字符串的第3，5，此时row是2x3-2=4，那么可以看出 3 % 4 = 3， 5 % 4 = 1，3 + 1 = 4 = 2 &lt;em&gt; numrows -2 。他们都属于a[1],所以可以用2&lt;/em&gt;numRows - 2 - row，来求出3的行数。&lt;br&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="medium" scheme="http://yoursite.com/tags/medium/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>python @装饰器</title>
    <link href="http://yoursite.com/2018/11/20/python-decorator/"/>
    <id>http://yoursite.com/2018/11/20/python-decorator/</id>
    <published>2018-11-20T09:08:11.000Z</published>
    <updated>2018-11-20T12:12:24.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><p>装饰器的用处是不需要大批量修改某函数就能实现为其增添功能。装饰器满足两点要求：  </p><ol><li>不能修改被装饰函数的源代码  </li><li>不能修改被装饰函数的调用方式  </li></ol><p>在讲解装饰器之前，我们还需要明白几个表达方式。对一个函数test1()来说：  </p><ol><li>test1表示的是函数的内存地址  </li><li>test1()就是在调用在test1这个地址的内容，也就是在调用函数  </li></ol><p>现在正式开始介绍装饰器的用法。<br><a id="more"></a> </p><h2 id="不带参数装饰器"><a href="#不带参数装饰器" class="headerlink" title="不带参数装饰器"></a>不带参数装饰器</h2><p>这里我们先假设我们有一个函数test，我们想在不改变函数代码和调用方式的前提下，实现对test的运行时间计算。<br>不使用装饰器的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">running_time</span><span class="params">()</span>:</span></span><br><span class="line">            print(<span class="string">'%s loaded'</span>%func)</span><br><span class="line">            start = time.time()</span><br><span class="line">            res = func()<span class="comment">#4</span></span><br><span class="line">            end = time.time()</span><br><span class="line">            print(<span class="string">'func running time is %s'</span>%(-start+end))</span><br><span class="line">            <span class="keyword">return</span> res <span class="comment">#6</span></span><br><span class="line">        <span class="keyword">return</span> running_time  <span class="comment">#2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span><span class="comment">#5</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'test is running'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'test finished'</span></span><br><span class="line"><span class="comment">#调用方式</span></span><br><span class="line">test = timer(test)<span class="comment">#1</span></span><br><span class="line">test()<span class="comment">#3</span></span><br></pre></td></tr></table></figure></p><p>上面的代码在最后两行调用的时候，我们先是把test作为内存地址传入timer，然后timer会执行#1，返回它的内嵌函数running_time的内存地址（注意不是调用），也就是说现在的test存的不再是test函数的内存地址，<br>而是running_time的内存地址，所以我们在#3调用test（）时，其实执行的是running_time，然后在running_time内部再调用test（），计算它的运行时间，大致的流程可以参考注释中的顺序。<br>它的输出如下：</p><pre><code>&lt;function test at 0x00C21A08&gt; loadedtest is runningfunc running time is 2.000366687774658test finished</code></pre><p>下面我们用@装饰器的语法来简化上述过程。只需要在被调用函数的前面加上@装饰器就可以了。最后函数的调用语句并没有改变（仍为test（）），这也完成了某种程度上对该函数的改写。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">running_time</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment">#1</span></span><br><span class="line">            print(<span class="string">'%s loaded'</span>%func)</span><br><span class="line">            start = time.time()</span><br><span class="line">            res = func(*args, **kwargs) <span class="comment">#2</span></span><br><span class="line">            end = time.time()</span><br><span class="line">            print(<span class="string">'func running time is %s'</span>%(-start+end))</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> running_time</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(parameters=None)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'test is running'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'test finished'</span></span><br><span class="line"> </span><br><span class="line">test()</span><br></pre></td></tr></table></figure></p><p>值得注意的是，被装饰的函数有时可能也有入参，那么我们可以在装饰器的内嵌函数的入参位置加上args和kwargs确保我们接受了全部的参数（见#1，#2），然后再传递给内嵌函数内对被装饰函数的调用处。<br>这段代码的输出和上一段一样。</p><h2 id="带参数装饰器"><a href="#带参数装饰器" class="headerlink" title="带参数装饰器"></a>带参数装饰器</h2><p>当我们有多个被装饰的函数时，我们可能需要在装饰器中将他们区分开来进行处理，这就需要@装饰器（parameter=value)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(parameter)</span>:</span> <span class="comment">#3</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inside_timer</span><span class="params">(func)</span>:</span> <span class="comment">#5</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">running_time</span><span class="params">()</span>:</span> <span class="comment">#7</span></span><br><span class="line">            print(<span class="string">'%s loaded'</span>%parameter)</span><br><span class="line">            start = time.time()</span><br><span class="line">            res = func() <span class="comment">#8</span></span><br><span class="line">            end = time.time()</span><br><span class="line">            print(<span class="string">'func running time is %s'</span>%(-start+end))</span><br><span class="line">            <span class="keyword">return</span> res  <span class="comment">#11</span></span><br><span class="line">        <span class="keyword">return</span> running_time <span class="comment">#6</span></span><br><span class="line">    <span class="keyword">return</span> inside_timer   <span class="comment">#4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(parameter='task1') #2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span> <span class="comment">#8</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'test is running'</span>) <span class="comment">#9 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'test finished'</span> <span class="comment">#10</span></span><br><span class="line">test() <span class="comment">#1</span></span><br></pre></td></tr></table></figure></p><p>输出是  </p><pre><code>task1 loaded  test is running  func running time is 2.000399112701416  test finished  </code></pre><p>如果我们不用装饰器这个语法，那么最后的调用过程为：</p><pre><code>timer=timer(parameter=value) #执行完毕后，timer存储的是inside_timer的内存地址test=timer(test)   #将test作为入参传入inside_timer，返回running_time的内存地址给testtest()    #这一步的执行过程和无参数的装饰器都一样</code></pre><h3 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h3><p>如果看完还有疑惑可以参考：<a href="http://lib.csdn.net/article/python/62942" target="_blank" rel="noopener">http://lib.csdn.net/article/python/62942</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;几个概念&quot;&gt;&lt;a href=&quot;#几个概念&quot; class=&quot;headerlink&quot; title=&quot;几个概念&quot;&gt;&lt;/a&gt;几个概念&lt;/h2&gt;&lt;p&gt;装饰器的用处是不需要大批量修改某函数就能实现为其增添功能。装饰器满足两点要求：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不能修改被装饰函数的源代码  &lt;/li&gt;
&lt;li&gt;不能修改被装饰函数的调用方式  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在讲解装饰器之前，我们还需要明白几个表达方式。对一个函数test1()来说：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;test1表示的是函数的内存地址  &lt;/li&gt;
&lt;li&gt;test1()就是在调用在test1这个地址的内容，也就是在调用函数  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在正式开始介绍装饰器的用法。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra 找最短路径</title>
    <link href="http://yoursite.com/2018/11/16/Dijkstra/"/>
    <id>http://yoursite.com/2018/11/16/Dijkstra/</id>
    <published>2018-11-16T14:43:54.000Z</published>
    <updated>2018-11-16T16:11:58.501Z</updated>
    
    <content type="html"><![CDATA[<p>寻找加权图G中src点到图中其他可抵达点的最短路径。我们用适应性强的优先队列去实现最小值提取，队列的选择有两种选择:<br>1.堆O((n+m)logn)<br>2.未排序的序列O(n^2)<br>当边的数量很少（m&lt;n^2/logn)用堆，反之序列。<br>下面的代码中我们用堆实现。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortest_path_lengths</span><span class="params">(g, src)</span>:</span></span><br><span class="line">    d = &#123;&#125; <span class="comment">#save the smallest weight from v to u</span></span><br><span class="line">    cloud = &#123;&#125; <span class="comment">#map reachable v to its d[v] value</span></span><br><span class="line">    pq = AdaptableHeapPriorityQueue() <span class="comment">#vertex v will have key d[v]</span></span><br><span class="line">    pqlocator = &#123;&#125; <span class="comment"># map from vertex to its pq locator </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#the source having distance 0 and the rest have infinite</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> g.vertices():</span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">is</span> scr:</span><br><span class="line">            d[v] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d[v] = float(inf)</span><br><span class="line">        pqlocator[v]=pq.add(d[v], v) <span class="comment">#save locator for future update</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> pq.is_empty():</span><br><span class="line">        key, u = pq.remove_min()</span><br><span class="line">        cloud[u] = key</span><br><span class="line">        <span class="keyword">del</span> pqlocator[u]</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> g.incident_edges(u):      <span class="comment">#incident_edges return a set of u's edges</span></span><br><span class="line">            v = e.opposite(u)    <span class="comment">#return the other side of the edge</span></span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> cloud:</span><br><span class="line">                wgt = e.element()        <span class="comment">#return the weight</span></span><br><span class="line">                <span class="keyword">if</span> d[u]+wgt &lt; d[v]:</span><br><span class="line">                    d[v] = d[u]+wgt      <span class="comment">#update the distance make sure it only gets smaller</span></span><br><span class="line">                    pq.update(pqlocator[v], d[v], v)</span><br><span class="line">    <span class="keyword">return</span> cloud        <span class="comment"># only include reachable vertices with shortest distance from src</span></span><br></pre></td></tr></table></figure></p><p>下面代码输出这个以src为源顶点的最小路径树。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortest_path_tree</span><span class="params">(g, s, cloud)</span>:</span></span><br><span class="line">    tree = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> cloud:</span><br><span class="line">        <span class="keyword">if</span> u <span class="keyword">is</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">for</span> e <span class="keyword">in</span> g.incident_edges(u, <span class="keyword">False</span>): <span class="comment">###!!!!the set of INCOMING edges！！！</span></span><br><span class="line">                v = e.opposite(u)</span><br><span class="line">                wgt = e.element()</span><br><span class="line">                <span class="keyword">if</span> wgt+cloud[v] == cloud[u]:   <span class="comment">###important step</span></span><br><span class="line">                    tree[u] = e</span><br><span class="line">    <span class="keyword">return</span> tree                                <span class="comment"># a dict(graph) of shortest edges</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;寻找加权图G中src点到图中其他可抵达点的最短路径。我们用适应性强的优先队列去实现最小值提取，队列的选择有两种选择:&lt;br&gt;1.堆O((n+m)logn)&lt;br&gt;2.未排序的序列O(n^2)&lt;br&gt;当边的数量很少（m&amp;lt;n^2/logn)用堆，反之序列。&lt;br&gt;下面的代码中我们用堆实现。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="加权图" scheme="http://yoursite.com/tags/%E5%8A%A0%E6%9D%83%E5%9B%BE/"/>
    
      <category term="最短路径" scheme="http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>可适应性优先级队列（基于堆）</title>
    <link href="http://yoursite.com/2018/11/16/AdaptableHeapPriorityQueue/"/>
    <id>http://yoursite.com/2018/11/16/AdaptableHeapPriorityQueue/</id>
    <published>2018-11-16T13:31:40.000Z</published>
    <updated>2018-11-16T14:52:07.742Z</updated>
    
    <content type="html"><![CDATA[<p>由于传统的堆并不支持对堆中除头和尾以外的位置的增删改，而在实际情况下我们需要对其他节点进行操作。这里我们在堆原有数据结构基础上进行扩展，<br>用’定位器‘来实现对堆中其他元素的定位。定位器是指在堆原有节点类中加入一个新属性_index（节点在底层数据结构数组中的秩），然后实列化节点类（locator），<br>并返回给用户用来定位每一个节点。<br><a id="more"></a><br>下面我们先展示基于原始堆的优先级排序数据结构的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapPriorityQueue</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">_Item</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">            self._key = key</span><br><span class="line">            self._val = value</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self._key &lt; other._key</span><br><span class="line"><span class="comment">### private behaviours</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_left</span><span class="params">(self, j)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*j+<span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_right</span><span class="params">(self, j)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*j+<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_parent</span><span class="params">(self, j)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (j<span class="number">-1</span>)//<span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_has_left</span><span class="params">(self, j)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._left(j) &lt; len(self._data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_has_right</span><span class="params">(self, j)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._right(j) &lt; len(self._data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_swap</span><span class="params">(self, i, j)</span>:</span>        </span><br><span class="line">        self._data[i], self._data[j] = self._data[j], self._data[i]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_downheap</span><span class="params">(self, j)</span>:</span>   <span class="comment">#向下冒泡</span></span><br><span class="line">        <span class="keyword">if</span> self._has_right(j):</span><br><span class="line">            small = self._right(j)</span><br><span class="line">            <span class="keyword">if</span> self._has_left(j):</span><br><span class="line">                <span class="keyword">if</span> self._data[self._left(j)] &lt; self._data[small]:</span><br><span class="line">                    small = self._left(j)</span><br><span class="line">            <span class="keyword">if</span> self._data[small] &lt; self._data[j]:</span><br><span class="line">                self._swap(small, j)</span><br><span class="line">                self._downheap(small)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_upheap</span><span class="params">(self, j)</span>:</span>   <span class="comment">#向上冒泡</span></span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> self._data[j] &lt; self._data[self._parent(j)]:</span><br><span class="line">            self._swap(j, self._parent(j))</span><br><span class="line">            self._upheap(self._parent(j)) </span><br><span class="line"><span class="comment">###public behaviours</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._data = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self)==<span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, k, v)</span>:</span></span><br><span class="line">        self._data.append(self._Item(k,v))</span><br><span class="line">        self._upheap(len(self._data)<span class="number">-1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'heap is empty'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._data[<span class="number">0</span>]._key, self._data[<span class="number">0</span>].val</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> ValueError</span><br><span class="line">        self._swap(<span class="number">0</span>, len(self._data)<span class="number">-1</span>)</span><br><span class="line">        item = self._data.pop()</span><br><span class="line">        self._downheap(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (item._key, item._val)</span><br></pre></td></tr></table></figure></p><p>接下来是适应性优先级队列，对于这个我们提供两种新方法：update（更新堆中某一节点），remove（删除某一节点）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdapatablePriorityHeapQueue</span><span class="params">(HeapPriorityQueue)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Locator</span><span class="params">(HeapProrityQueue._Item)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k, v, index)</span>:</span></span><br><span class="line">            super().__init__(k,v)</span><br><span class="line">            self._index = index</span><br><span class="line"><span class="comment">### private behaviours    </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_swap</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        super()._swap(i, j)</span><br><span class="line">        self._data[i]._index = i</span><br><span class="line">        self._data[j]._index = j</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_bubble</span><span class="params">(self, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;j <span class="keyword">and</span> self._data[j] &lt; self._data[self._parent(j)]:</span><br><span class="line">            self._upheap(j)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._downheap(j)</span><br><span class="line"><span class="comment">### public behaviours</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, k, v)</span>:</span></span><br><span class="line">        loc = self.Locator(k, v, len(self))</span><br><span class="line">        self._data.append(loc)</span><br><span class="line">        self._upheap(len(self._data)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> loc</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, loc, k, v)</span>:</span></span><br><span class="line">        j = loc._index</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span>&lt;=j&lt;len(self)) <span class="keyword">and</span> self._data[j]==loc:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'invalid locator'</span>)</span><br><span class="line">        loc._key = k</span><br><span class="line">        loc._val = v</span><br><span class="line">        <span class="keyword">return</span> loc</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, loc)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> ValueError</span><br><span class="line">        j = loc._index</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span>&lt;=j&lt;len(self)) <span class="keyword">and</span> self._data[j]==loc:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'invalid locator'</span>)</span><br><span class="line">        <span class="keyword">if</span> j != len(self)<span class="number">-1</span>:</span><br><span class="line">            self._swap(j, len(self)<span class="number">-1</span>)</span><br><span class="line">            self._bubble(j)</span><br><span class="line">        self._data.pop()</span><br><span class="line">        <span class="keyword">return</span> (loc._key, loc._val)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于传统的堆并不支持对堆中除头和尾以外的位置的增删改，而在实际情况下我们需要对其他节点进行操作。这里我们在堆原有数据结构基础上进行扩展，&lt;br&gt;用’定位器‘来实现对堆中其他元素的定位。定位器是指在堆原有节点类中加入一个新属性_index（节点在底层数据结构数组中的秩），然后实列化节点类（locator），&lt;br&gt;并返回给用户用来定位每一个节点。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 25 k个一组反转链表</title>
    <link href="http://yoursite.com/2018/11/16/leetcode-25/"/>
    <id>http://yoursite.com/2018/11/16/leetcode-25/</id>
    <published>2018-11-16T04:23:49.000Z</published>
    <updated>2018-11-16T05:01:00.982Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><pre><code>给出一个链表，每k个一组进行翻转，并返回翻转后的链表。如果节点总数不是k的整数倍，那么将剩余节点保持原序返回。例子：    给出：1-&gt;2-&gt;3-&gt;4-&gt;5, k=3    输出：3-&gt;2-&gt;1-&gt;4-&gt;5说明：    1. 你的算法只能使用常数的额外空间    2. 不能单纯的改变节点的值，需要对实际节点进行交换</code></pre><p>首先要判断链表长度是否大于k，然后再进行分组翻转。由于会有剩余部分，不要忽略翻转完毕后对剩余部分的重新连接。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python 3</span></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        start = head</span><br><span class="line">        pre = cur = new = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            head = head.next</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; length: <span class="keyword">return</span> start  <span class="comment">#!!!start is the original head, head already move to NULL!!!</span></span><br><span class="line">        t = length // k</span><br><span class="line">        <span class="keyword">while</span> t &gt; <span class="number">0</span>:</span><br><span class="line">            cur, new = self.reverse(start, k)</span><br><span class="line">            <span class="keyword">if</span> pre <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                res = cur <span class="comment">#!!!cur is the new head not start!!!</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.next = cur</span><br><span class="line">            pre = start</span><br><span class="line">            start = new</span><br><span class="line">            t -= <span class="number">1</span></span><br><span class="line">        pre.next = start <span class="comment">#!!!do not forget to connect the rest of the list!!!</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, start, k)</span>:</span></span><br><span class="line">        cur, pre = start, <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            temp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = temp</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> pre, cur</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;给出一个链表，每k个一组进行翻转，并返回翻转后的链表。
如果节点总数不是k的整数倍，那么将剩余节点保持原序返回。
例子：
    给出：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, k=3
    输出：3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5
说明：
    1. 你的算法只能使用常数的额外空间
    2. 不能单纯的改变节点的值，需要对实际节点进行交换
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先要判断链表长度是否大于k，然后再进行分组翻转。由于会有剩余部分，不要忽略翻转完毕后对剩余部分的重新连接。&lt;br&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="hard" scheme="http://yoursite.com/tags/hard/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 92 反转m到n的链表</title>
    <link href="http://yoursite.com/2018/11/14/leetcode-92/"/>
    <id>http://yoursite.com/2018/11/14/leetcode-92/</id>
    <published>2018-11-14T15:47:01.000Z</published>
    <updated>2018-11-16T05:00:58.834Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><pre><code>反转从位置m到n的链表。请使用一趟扫描完成反转。(1&lt;=m&lt;=n&lt;=lenofthelist)例子:    input：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m=2, n=4    output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL    </code></pre><p>首先记录m-1的节点(front)，然后依次倒置[m,n]之间的节点，期间还要注意m节点的收藏(tail)，用来设置tail.next=back，然后记录n+1(back)节点，最后完成n+1，m-1连接。由于倒置是通过不停的选择next节点来完成，为了防止陷入死循环，本次节点(cur)与本次节点next节点(temp)的关系倒置要放到下一次循环中处理，这就需要我们引入pre来记录本次节点。<br>简而言之，介于[m,n]间的单次循环要完成两项任务：1. 设置temp 2. 完成cur.next = pre。<br>另外，几个需要注意的小细节，这里的m,n指的是位置，不是类似于数组的秩，是从1开始的。所以在循环倒置时，i也应先加1，表示此次是对第一个位置操作。<br><a href="https://leetcode.com/problems/reverse-linked-list-ii/discuss/184849/Python-Solution-20ms-beats-100?from=singlemessage&amp;isappinstalled=0" target="_blank" rel="noopener">代码来源</a><br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        cur = head</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        back = tail = front = pre = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> i &lt; n+<span class="number">1</span>:</span><br><span class="line">            i += <span class="number">1</span>             </span><br><span class="line">            <span class="keyword">if</span> m &lt;= i &lt;= n:</span><br><span class="line">                tmp = cur.next <span class="comment">#task 1</span></span><br><span class="line">                <span class="keyword">if</span> pre <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                    tail = cur <span class="comment">#record m</span></span><br><span class="line">                cur.next = pre <span class="comment">#task 2</span></span><br><span class="line">                pre = cur</span><br><span class="line">                cur = tmp</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i == m<span class="number">-1</span>:</span><br><span class="line">                    front = cur <span class="comment">#record m-1</span></span><br><span class="line">                <span class="keyword">elif</span> i == n+<span class="number">1</span>:</span><br><span class="line">                    back = cur</span><br><span class="line">                cur = cur.next <span class="comment"># !!move to the next!!</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> front:</span><br><span class="line">            front.next = pre</span><br><span class="line">            res = head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = pre</span><br><span class="line">        tail.next = back</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;反转从位置m到n的链表。请使用一趟扫描完成反转。(1&amp;lt;=m&amp;lt;=n&amp;lt;=lenofthelist)
例子:
    input：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m=2, n=4
    output: 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先记录m-1的节点(front)，然后依次倒置[m,n]之间的节点，期间还要注意m节点的收藏(tail)，用来设置tail.next=back，然后记录n+1(back)节点，最后完成n+1，m-1连接。由于倒置是通过不停的选择next节点来完成，为了防止陷入死循环，本次节点(cur)与本次节点next节点(temp)的关系倒置要放到下一次循环中处理，这就需要我们引入pre来记录本次节点。&lt;br&gt;简而言之，介于[m,n]间的单次循环要完成两项任务：1. 设置temp 2. 完成cur.next = pre。&lt;br&gt;另外，几个需要注意的小细节，这里的m,n指的是位置，不是类似于数组的秩，是从1开始的。所以在循环倒置时，i也应先加1，表示此次是对第一个位置操作。&lt;br&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list-ii/discuss/184849/Python-Solution-20ms-beats-100?from=singlemessage&amp;amp;isappinstalled=0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;代码来源&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="medium" scheme="http://yoursite.com/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>HEXO部署到GitHub.io搭建个人博客</title>
    <link href="http://yoursite.com/2018/11/13/HEXO%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2018/11/13/HEXO部署/</id>
    <published>2018-11-13T12:07:42.000Z</published>
    <updated>2018-11-14T17:06:18.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="install-git"><a href="#install-git" class="headerlink" title="install git"></a><a href="https://github.com/funcab/notes/blob/master/git/usage.md" target="_blank" rel="noopener">install git</a></h2><h2 id="install-Node-js"><a href="#install-Node-js" class="headerlink" title="install Node.js"></a>install Node.js</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure><p>Close and reopen your terminal to start using nvm or run the following to use it now:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install stable</span><br></pre></td></tr></table></figure><a id="more"></a> <h2 id="install-Hexo-and-init"><a href="#install-Hexo-and-init" class="headerlink" title="install Hexo and init"></a>install Hexo and init</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">mkdir &lt;folder&gt;</span><br><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="install-NexT"><a href="#install-NexT" class="headerlink" title="install NexT"></a>install NexT</h2><p>Download latest release version:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir themes/next</span><br><span class="line">curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url </span><br><span class="line">| cut -d &apos;&quot;&apos; -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1</span><br></pre></td></tr></table></figure></p><p>Set theme in main hexo root config _config.yml file:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></p><h2 id="github-pages"><a href="#github-pages" class="headerlink" title="github pages"></a>github pages</h2><p>install plugins:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>edit <folder>/_config.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://[github用户名]:[github密码]@github.com/xxx/xxx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></folder></p><p>push to github：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure></p><p>publish new blog:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &apos;blogname&apos;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;install-git&quot;&gt;&lt;a href=&quot;#install-git&quot; class=&quot;headerlink&quot; title=&quot;install git&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/funcab/notes/blob/master/git/usage.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;install git&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;install-Node-js&quot;&gt;&lt;a href=&quot;#install-Node-js&quot; class=&quot;headerlink&quot; title=&quot;install Node.js&quot;&gt;&lt;/a&gt;install Node.js&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Close and reopen your terminal to start using nvm or run the following to use it now:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export NVM_DIR=&amp;quot;$HOME/.nvm&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[ -s &amp;quot;$NVM_DIR/nvm.sh&amp;quot; ] &amp;amp;&amp;amp; \. &amp;quot;$NVM_DIR/nvm.sh&amp;quot;  # This loads nvm&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nvm install stable&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="HEXO" scheme="http://yoursite.com/tags/HEXO/"/>
    
      <category term="搭建个人博客" scheme="http://yoursite.com/tags/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
