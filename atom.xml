<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LINJING BI</title>
  
  <subtitle>biubiubiu...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-28T05:07:15.935Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Bi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python线程池解析及自制线程池(基础款)</title>
    <link href="http://yoursite.com/2018/12/28/DIY-ThreadingPool/"/>
    <id>http://yoursite.com/2018/12/28/DIY-ThreadingPool/</id>
    <published>2018-12-28T02:28:00.000Z</published>
    <updated>2018-12-28T05:07:15.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要线程池"><a href="#为什么需要线程池" class="headerlink" title="为什么需要线程池"></a>为什么需要线程池</h2><p>目前的大多数网络服务器，包括Web服务器、Email服务器以及数据库服务器等都具有一个共同点，就是单位时间内必须处理数目巨大的连接请求，但处理时间却相对较短。<br>传统多线程方案中我们采用的服务器模型则是一旦接受到请求之后，即创建一个新的线程，由该线程执行任务。任务执行完毕后，线程退出，这就是是“即时创建， 即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数极其频繁，那么服务器将处于不停的创建线程，销毁线程的状态。<br>我们将传统方案中的线程执行过程分为三个过程：T1、T2、T3：<br>T1：线程创建时间<br>T2：线程执行时间，包括线程的同步等时间<br>T3：线程销毁时间<br>那么我们可以看出，线程本身的开销所占的比例为(T1+T3) / (T1+T2+T3)。如果线程执行的时间很短的话，这比开销可能占到20%-50%左右。如果任务执行时间很频繁的话，这笔开销将是不可忽略的。<br>除此之外，线程池能够减少创建的线程个数。通常线程池所允许的并发线程是有上界的，如果同时需要并发的线程数超过上界，那么一部分线程将会等待。而传统方案中，如果同时请求数目为2000，那么最坏情况下，系统可能需要产生2000个线程。尽管这不是一个很大的数目，但是也有部分机器可能达不到这种要求。<br>因此线程池的出现正是着眼于减少线程池本身带来的开销。线程池采用预创建的技术，在应用程序启动之后，将立即创建一定数量的线程(N1)，放入空闲队列 中。这些线程都是处于阻塞（Suspended）状态，不消耗CPU，但占用较小的内存空间。当任务到来后，缓冲池选择一个空闲线程，把任务传入此线程中运行。当N1个线程都在处理任务后，缓冲池自动创建一定数量的新线程，用于处理更多的任务。在任务执行完毕后线程也不退出，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源。<br>基于这种预创建技术，线程池将线程创建和销毁本身所带来的开销分摊到了各个具体的任务上，执行次数越多，每个任务所分担到的线程本身开销则越小，不过我们另外可能需要考虑进去线程之间同步所带来的开销。  </p><h2 id="Python自带的ThreadPoolExecutor"><a href="#Python自带的ThreadPoolExecutor" class="headerlink" title="Python自带的ThreadPoolExecutor"></a>Python自带的ThreadPoolExecutor</h2><p>我用的python3.6，使用的是线程池来自concurrent.futures。下面我先简单介绍一下线程池的实现，ThreadPoolExecutor的详细使用可以参看我的github相应模块：<a href="https://github.com/LinjingBi/python_multiplexing/blob/master/multiplexing/chapter_2/threadpool_concurrent_futures.py" target="_blank" rel="noopener">github内容</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python 3.6</span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(a)</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:    </span><br><span class="line">    executor = ThreadPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 注意函数的名称和参数分开输入</span></span><br><span class="line">    <span class="comment"># submit之后会立马返回一个Future对象不管线程池是否已满，</span></span><br><span class="line">    <span class="comment"># 基于这个Future对象我们就可以对线程的运行状态，result等进行查询</span></span><br><span class="line">    <span class="comment"># 放入之后线程池会根据满空状态自动安排运行</span></span><br><span class="line">    thread1 = executor.submit(test,(<span class="number">1</span>,))</span><br></pre></td></tr></table></figure><a id="more"></a> <p>以上是ThreadPoolExecutor的API，接下来我们来看看ThreadPoolExecutor内部是如何实现的，以下内容来自ThreadPoolExecutor源码。<br>首先看看<strong>init</strong>()，我们首先声明了线程池的几个基本属性：  </p><ul><li>self._max_workers：最大线程数</li><li>self._work_queue：等待队列</li><li>self._threads：线程集合</li><li>self._shutdown, self._shutdown_lock：实现手动关闭线程池</li><li>self._thread_name_prefix：个性化定制<br>这也给了我们一个线程池的雏形，我们在自制的时候可以参考。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span><span class="params">(_base.Executor)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Used to assign unique thread names when thread_name_prefix is not supplied.</span></span><br><span class="line">    _counter = itertools.count().__next__</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max_workers=None, thread_name_prefix=<span class="string">''</span>)</span>:</span></span><br><span class="line">        <span class="string">"""Initializes a new ThreadPoolExecutor instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            max_workers: The maximum number of threads that can be used to</span></span><br><span class="line"><span class="string">                execute the given calls.</span></span><br><span class="line"><span class="string">            thread_name_prefix: An optional name prefix to give our threads.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> max_workers <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="comment"># Use this number because ThreadPoolExecutor is often</span></span><br><span class="line">            <span class="comment"># used to overlap I/O instead of CPU work.</span></span><br><span class="line">            max_workers = (os.cpu_count() <span class="keyword">or</span> <span class="number">1</span>) * <span class="number">5</span></span><br><span class="line">        <span class="keyword">if</span> max_workers &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"max_workers must be greater than 0"</span>)</span><br><span class="line"></span><br><span class="line">        self._max_workers = max_workers <span class="comment"># 最大线程数，可以手动设定，或者默认跟计算机内核数相关</span></span><br><span class="line">        self._work_queue = queue.Queue() <span class="comment"># 存储所有通过submit提交的函数，如果以及被执行就会弹出队列。类型是线程安全的queue.Queue()</span></span><br><span class="line">        self._threads = set() <span class="comment"># 存储线程池中的活跃线程</span></span><br><span class="line">        self._shutdown = <span class="keyword">False</span>  <span class="comment"># 服务于.shutdown(),使得线程池可以被程序员手动关闭</span></span><br><span class="line">        self._shutdown_lock = threading.Lock()  <span class="comment"># 服务于.shutdown()和.submit(),保证这两个过程不会被打断，是线程安全的</span></span><br><span class="line">        self._thread_name_prefix = (thread_name_prefix <span class="keyword">or</span></span><br><span class="line">                                    (<span class="string">"ThreadPoolExecutor-%d"</span> % self._counter()))</span><br></pre></td></tr></table></figure><p>接下来看最核心的submit函数的源码，终于可以愉快的添加注释啦。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submit</span><span class="params">(self, fn, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># 保证在submit的过程中不会被粗暴的关闭以及打断</span></span><br><span class="line">    <span class="keyword">with</span> self._shutdown_lock:</span><br><span class="line">    <span class="comment"># 如果已经被关闭，就不能再加啦</span></span><br><span class="line">        <span class="keyword">if</span> self._shutdown:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">'cannot schedule new futures after shutdown'</span>)</span><br><span class="line">        <span class="comment"># 会为每个提交函数创建一个Future对象，这个很重要，</span></span><br><span class="line">        <span class="comment"># 通过这个Future类可以查询的线程的运行状态以及返回值，这是单纯的threading.Thread做不到的</span></span><br><span class="line">        f = _base.Future()</span><br><span class="line">        <span class="comment"># 这个_WorkIthem的作用类似于threading.Thread的run(),因为在线程池里所有的线程都是以Future类的形式存在的，</span></span><br><span class="line">        <span class="comment"># 所以要通过_WorkItem来为每个Future绑定一个run()的函数</span></span><br><span class="line"></span><br><span class="line">        w = _WorkItem(f, fn, args, kwargs)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 放入等待队列</span></span><br><span class="line">        self._work_queue.put(w)</span><br><span class="line">        <span class="comment"># 线程池真正的运行函数</span></span><br><span class="line">        self._adjust_thread_count()</span><br><span class="line">        <span class="comment"># 立即返回future对象</span></span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure></p><p>接下来看看self._adjust_thread_count()。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_adjust_thread_count</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># When the executor gets lost, the weakref callback will wake up</span></span><br><span class="line">    <span class="comment"># the worker threads.</span></span><br><span class="line">    <span class="comment"># 这里定义了弱引用的callback函数。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weakref_cb</span><span class="params">(_, q=self._work_queue)</span>:</span></span><br><span class="line">        q.put(<span class="keyword">None</span>)</span><br><span class="line">    <span class="comment"># TODO(bquinlan): Should avoid creating new threads if there are more</span></span><br><span class="line">    <span class="comment"># idle threads than items in the work queue.</span></span><br><span class="line">    num_threads = len(self._threads)</span><br><span class="line">    <span class="keyword">if</span> num_threads &lt; self._max_workers:</span><br><span class="line">        thread_name = <span class="string">'%s_%d'</span> % (self._thread_name_prefix <span class="keyword">or</span> self,</span><br><span class="line">                                 num_threads)</span><br><span class="line">        <span class="comment"># 这里的target和args的应用可以说是非常专业了，下方会特别讲</span></span><br><span class="line">        t = threading.Thread(name=thread_name, target=_worker,</span><br><span class="line">                             args=(weakref.ref(self, weakref_cb),</span><br><span class="line">                                   self._work_queue))</span><br><span class="line">        t.daemon = <span class="keyword">True</span></span><br><span class="line">        t.start()</span><br><span class="line">        self._threads.add(t)</span><br><span class="line">        _threads_queues[t] = self._work_queue</span><br></pre></td></tr></table></figure></p><p>其实，这个线程池的逻辑是很简单但高效的，我被卡住的地方是一些很细节的东西，比如self._thread只有add，那么是怎么删掉跑完的线程啊，以及注释提到的weakref。<br>但是在我查了weakref的作用的时候，我觉得这两点都跟python的垃圾回收机制有关。我们可以看到weakref.ref(self, weakref_cb),它是对我们的线程池实例（self）作了弱引用。<br>如果一个对象有一个常规引用，它是不会被垃圾回收机制回收的，如果一个对象只剩下一个弱引用，那么他可能被垃圾回收机制回收，而weakref_cb是他被删除时的回调函数。这也说明这段代码在<br>完成线程池的基本逻辑之外还兼顾了垃圾回收机制，不愧是源码，跪拜。当然关于一个Thread对象怎么从self._thread中删除，我也很好奇，可能也是跟垃圾回收有关。但需要强调的是，就算线程数是满的<br>也不会导致刚submit的函数被永远耽误，因为在submit中他们已经被put进入了self._work_queue这个线程间通信用的queue了，也就说它是可以被每个活跃的线程看的，并且run的。  </p><h2 id="自制的线程池"><a href="#自制的线程池" class="headerlink" title="自制的线程池"></a>自制的线程池</h2><p>这是一个基础款的线程池，实现的基本功能有限制等待队列的数量以及限制线程的数量，由于逻辑简单，就直接上代码啦。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3.6</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerPool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maximum_wait=None, maximum_worker=None)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> work_queue</span><br><span class="line">        work_queue = queue.Queue(maximum_wait)</span><br><span class="line">        self._thread_num = maximum_worker</span><br><span class="line">        self._worker = set()</span><br><span class="line">        self._init_thread_pool()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init_thread_pool</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self._thread_num):</span><br><span class="line">            worker = _Worker()</span><br><span class="line">            self._worker.add(worker)</span><br><span class="line">            worker.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_thread</span><span class="params">(self, fn, args=<span class="params">()</span>, kwargs=None)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> work_queue</span><br><span class="line">        <span class="comment"># 这里注意按照这样的方式处理args，kwargs是可以直接带入fn的</span></span><br><span class="line">        <span class="keyword">if</span> kwargs <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            kwargs = &#123;&#125;</span><br><span class="line">        para = (fn, args, kwargs)</span><br><span class="line">        work_queue.put(para)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait_complete</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> worker <span class="keyword">in</span> self._worker:</span><br><span class="line">            <span class="keyword">if</span> worker.isAlive():</span><br><span class="line">                worker.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Worker</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> work_queue</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 当work_queue空了之后，十秒内没有新的目标进入就自动关闭</span></span><br><span class="line">                fn, args, kwargs = work_queue.get(block=<span class="keyword">True</span>, timeout=<span class="number">10</span>)</span><br><span class="line">                <span class="comment"># 注意args，kwargs的格式</span></span><br><span class="line">                fn(*args, **kwargs)</span><br><span class="line">                work_queue.task_done()  <span class="comment"># 注意Queue要用join一定要先task_done()</span></span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(a)</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pool = WorkerPool(<span class="number">20</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="comment"># 请按照threading.thread(target=, args=())的方式书写</span></span><br><span class="line">        pool.add_thread(fn=test, args=(i,))</span><br><span class="line">    pool.wait_complete()</span><br></pre></td></tr></table></figure></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/iamaiearner/article/details/9371315" target="_blank" rel="noopener">weakref模块</a><br><a href="https://www.cnblogs.com/goodhacker/p/3359985.html" target="_blank" rel="noopener">线程池</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么需要线程池&quot;&gt;&lt;a href=&quot;#为什么需要线程池&quot; class=&quot;headerlink&quot; title=&quot;为什么需要线程池&quot;&gt;&lt;/a&gt;为什么需要线程池&lt;/h2&gt;&lt;p&gt;目前的大多数网络服务器，包括Web服务器、Email服务器以及数据库服务器等都具有一个共同点，就是单位时间内必须处理数目巨大的连接请求，但处理时间却相对较短。&lt;br&gt;传统多线程方案中我们采用的服务器模型则是一旦接受到请求之后，即创建一个新的线程，由该线程执行任务。任务执行完毕后，线程退出，这就是是“即时创建， 即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数极其频繁，那么服务器将处于不停的创建线程，销毁线程的状态。&lt;br&gt;我们将传统方案中的线程执行过程分为三个过程：T1、T2、T3：&lt;br&gt;T1：线程创建时间&lt;br&gt;T2：线程执行时间，包括线程的同步等时间&lt;br&gt;T3：线程销毁时间&lt;br&gt;那么我们可以看出，线程本身的开销所占的比例为(T1+T3) / (T1+T2+T3)。如果线程执行的时间很短的话，这比开销可能占到20%-50%左右。如果任务执行时间很频繁的话，这笔开销将是不可忽略的。&lt;br&gt;除此之外，线程池能够减少创建的线程个数。通常线程池所允许的并发线程是有上界的，如果同时需要并发的线程数超过上界，那么一部分线程将会等待。而传统方案中，如果同时请求数目为2000，那么最坏情况下，系统可能需要产生2000个线程。尽管这不是一个很大的数目，但是也有部分机器可能达不到这种要求。&lt;br&gt;因此线程池的出现正是着眼于减少线程池本身带来的开销。线程池采用预创建的技术，在应用程序启动之后，将立即创建一定数量的线程(N1)，放入空闲队列 中。这些线程都是处于阻塞（Suspended）状态，不消耗CPU，但占用较小的内存空间。当任务到来后，缓冲池选择一个空闲线程，把任务传入此线程中运行。当N1个线程都在处理任务后，缓冲池自动创建一定数量的新线程，用于处理更多的任务。在任务执行完毕后线程也不退出，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源。&lt;br&gt;基于这种预创建技术，线程池将线程创建和销毁本身所带来的开销分摊到了各个具体的任务上，执行次数越多，每个任务所分担到的线程本身开销则越小，不过我们另外可能需要考虑进去线程之间同步所带来的开销。  &lt;/p&gt;
&lt;h2 id=&quot;Python自带的ThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#Python自带的ThreadPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;Python自带的ThreadPoolExecutor&quot;&gt;&lt;/a&gt;Python自带的ThreadPoolExecutor&lt;/h2&gt;&lt;p&gt;我用的python3.6，使用的是线程池来自concurrent.futures。下面我先简单介绍一下线程池的实现，ThreadPoolExecutor的详细使用可以参看我的github相应模块：&lt;a href=&quot;https://github.com/LinjingBi/python_multiplexing/blob/master/multiplexing/chapter_2/threadpool_concurrent_futures.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github内容&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#python 3.6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; concurrent.futures &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; ThreadPoolExecutor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(a)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&#39;__main__&#39;&lt;/span&gt;:    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = ThreadPoolExecutor(max_workers=&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 注意函数的名称和参数分开输入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# submit之后会立马返回一个Future对象不管线程池是否已满，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 基于这个Future对象我们就可以对线程的运行状态，result等进行查询&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 放入之后线程池会根据满空状态自动安排运行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    thread1 = executor.submit(test,(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="多线程编程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-53 最大子数组</title>
    <link href="http://yoursite.com/2018/12/19/leetcode-53/"/>
    <id>http://yoursite.com/2018/12/19/leetcode-53/</id>
    <published>2018-12-19T03:01:26.000Z</published>
    <updated>2018-12-19T12:24:18.390Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><pre><code>找到一个整数数组的最大累加和子数组例子：Input: [-2,1,-3,4,-1,2,1,-5,4]Output: 6Explanation: [4,-1,2,1]有最大累加和=6。</code></pre><p>这道题用到了Kadane‘s 算法。算法指出，在数组A中，如果我们知道一个以位置i为截至元素的最大累加和子数组Bi，那么在i+1位置上的最大累积和子数组Bi+1<br>要么是一个前缀为Bi的子数组，要么不是。Bi+1 = max（Bi+A[i+1],A[i+1]）。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    cursum = maxsum = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">        cursum = max(num, num+cursum) <span class="comment">#这行代码是对kadane’s的诠释，我们企图找到一个更长的子数组或者重新开始一个子数组</span></span><br><span class="line">        maxsum = max(maxsum, cursum) <span class="comment">#maxsum用来存储最大子数组的历史纪录，并时刻刷新记录</span></span><br><span class="line">    <span class="keyword">return</span> maxsum</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;找到一个整数数组的最大累加和子数组
例子：
Input: [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1]有最大累加和=6。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这道题用到了Kadane‘s 算法。算法指出，在数组A中，如果我们知道一个以位置i为截至元素的最大累加和子数组Bi，那么在i+1位置上的最大累积和子数组Bi+1&lt;br&gt;要么是一个前缀为Bi的子数组，要么不是。Bi+1 = max（Bi+A[i+1],A[i+1]）。&lt;br&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="easy" scheme="http://yoursite.com/tags/easy/"/>
    
      <category term="Kadane&#39;s Algorithm" scheme="http://yoursite.com/tags/Kadane-s-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-220 存在重复元素 III</title>
    <link href="http://yoursite.com/2018/12/18/leetcode-220/"/>
    <id>http://yoursite.com/2018/12/18/leetcode-220/</id>
    <published>2018-12-18T09:43:52.000Z</published>
    <updated>2018-12-18T15:04:16.284Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h3><pre><code>检测一个包含整数的数组中是否存在nums[j],nums[i],使得nums[i]-nums[j]的绝对值不超过t，并且i和j的距离不超过k。例子：Input：nums = [1,2,3,1], k=3, t=0Output: true</code></pre><a id="more"></a> <p>这道题使用桶排序，虽然桶排序占据的空间较大，但速度更快。先把题目要求翻译成不等式会更方便写出代码：<br>    设数组中任意两个满足题目要求的整数为v1，v2，假设v1是已知的，v2是要寻找的满足条件的整数。<br>    |v1-v2|&lt;=t<br>    -t &lt;= v1-v2 &lt;= t<br>    -1 &lt;= v1/t - v2/t &lt;= 1<br>    v1/t-1 &lt;= v2/t &lt;= v1/t+1<br>    由此，我们就有了在桶中寻找符合条件的v2的范围。<br>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(self, nums, k, t)</span>:</span></span><br><span class="line">        bucket = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            bucketindex, offset = (v//t, <span class="number">1</span>) <span class="keyword">if</span> t <span class="keyword">else</span> (v, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> idex <span class="keyword">in</span> range(bucketindex - offset, bucketindex + offset + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> idex <span class="keyword">in</span> bucket <span class="keyword">and</span> abs(bucket[idex]-nums[i]) &lt;= t: <span class="comment">#由于//取整后，范围并不是推导出来的严格的范围，所以在范围内之后还要确定是否满足差为t</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            bucket[bucketindex] = nums[i]</span><br><span class="line">            <span class="keyword">if</span> len(bucket) &gt; k:</span><br><span class="line">                <span class="keyword">del</span> bucket[nums[i-k]//t <span class="keyword">if</span> t <span class="keyword">else</span> nums[i-k]] <span class="comment">#相当于以k为周期向数组尾部移动，因此需要每次删掉周期内第一个元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><p>这个方法十分巧妙，由于t&gt;=0，所以bucket内并不会有重复的元素，因为只要重复元素出现的间隔在k以内，都会在第二个for循环内部被返回true。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目:&quot;&gt;&lt;/a&gt;题目:&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;检测一个包含整数的数组中是否存在nums[j],nums[i],
使得nums[i]-nums[j]的绝对值不超过t，并且i和j的距离不超过k。
例子：
Input：nums = [1,2,3,1], k=3, t=0
Output: true
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="middle" scheme="http://yoursite.com/tags/middle/"/>
    
      <category term="桶排序" scheme="http://yoursite.com/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python多线程编程</title>
    <link href="http://yoursite.com/2018/12/06/python-multiplexing/"/>
    <id>http://yoursite.com/2018/12/06/python-multiplexing/</id>
    <published>2018-12-06T02:54:59.000Z</published>
    <updated>2018-12-06T13:31:09.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python的threading模块"><a href="#python的threading模块" class="headerlink" title="python的threading模块"></a>python的threading模块</h2><h3 id="一、线程"><a href="#一、线程" class="headerlink" title="一、线程"></a>一、线程</h3><p>线程是操作系统能够进行运算调度的最小单位。线程被包含在进程中，是进程中实际处理单位。<br>一条线程是指进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><h3 id="二、进程"><a href="#二、进程" class="headerlink" title="二、进程"></a>二、进程</h3><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><h3 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h3><p>进程是一块包含了某些资源的内存区域。操作系统利用进程把它的工作划分为一些功能单元。<br>进程中所包含的一个或多个执行单元成为线程。进程还拥有一个私有的虚拟地址空间，该进程空间仅能被它所包含的线程访问。<br>线程只能归属于一个进程并且它只能访问该进程所拥有的资源，一个进程下的所有线程共享该进程的资源。当操作系统创建一个进程后，该进程自动申请一个名为主线程或首要线程的线程。<br>处理计算密集型任务或函数用<strong>进程</strong><br>处理IO密集型任务或函数用<strong>线程</strong>  </p><h3 id="四、GIL"><a href="#四、GIL" class="headerlink" title="四、GIL"></a>四、GIL</h3><p>首先，GIL并不是Python的特性，它是在实现Python解析器（CPython）时所引入的一个概念。<br>同一段代码可以在CPython，PyPy，Psyco等不同的Python执行环境中运行，其中PyPy就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境，所以CPython的GIL缺陷也就约等在了Python身上。<br>GIL特性:<br>   python中的一个线程对应于c语言中的一个线程（CPython）<br>   GIL使得同一时刻只有一个线程在CPU上执行字节代码，无法将多个线程映射到多个CPU上去执行。<br>   GIL会很据执行的字节码行数以及时间片释放GIL，GIL在遇到io操作时会主动释放</p><p>   也就是说 <strong>在同一时刻，只有一个线程进入CPython解释器</strong><br>解决GIL限制的办法：  </p><pre><code>1. 多进程编程：既然多线程不能同时进入CPython解释器，我们可以通过把多个线程放入不同进程中，让多进程进入CPython解释器，分配给各个CPU，以利用多核实现并行。  2. 协程：后面会讲到</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;python的threading模块&quot;&gt;&lt;a href=&quot;#python的threading模块&quot; class=&quot;headerlink&quot; title=&quot;python的threading模块&quot;&gt;&lt;/a&gt;python的threading模块&lt;/h2&gt;&lt;h3 id=&quot;一
      
    
    </summary>
    
      <category term="python多线程编程" scheme="http://yoursite.com/categories/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Socket网络编程-Notebook</title>
    <link href="http://yoursite.com/2018/12/02/socket-start-notebook/"/>
    <id>http://yoursite.com/2018/12/02/socket-start-notebook/</id>
    <published>2018-12-02T02:39:30.000Z</published>
    <updated>2018-12-02T04:14:37.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>socket通常也称作套接字，用于描述IP地址和端口，用于连接应用层与传输层。  </p><p>socket网络编程流程见下图：<br><img src="https://raw.githubusercontent.com/LinjingBi/Hexo-images/master/socket.PNG" alt="socket1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Socket&quot;&gt;&lt;a href=&quot;#Socket&quot; class=&quot;headerlink&quot; title=&quot;Socket&quot;&gt;&lt;/a&gt;Socket&lt;/h1&gt;&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一
      
    
    </summary>
    
      <category term="socket网络编程" scheme="http://yoursite.com/categories/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="socket" scheme="http://yoursite.com/tags/socket/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 58 最后一个单词的长度</title>
    <link href="http://yoursite.com/2018/11/20/leetcode-58/"/>
    <id>http://yoursite.com/2018/11/20/leetcode-58/</id>
    <published>2018-11-20T14:41:41.000Z</published>
    <updated>2018-11-20T15:00:53.673Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><pre><code>给定一个仅包含大小写字母和空格&apos; &apos;的字符串，返回其最后一个单词的长度。如果不存在返回0例子：输入：&apos;Hello World’输出：5</code></pre><p>这个例子用python的str.split()很简单，只是想强调一下，当str为空或者全是’ ‘时，得到的列表也为空，此时不能用[-1]找最后一个元素。还有，如果a不为空或者全’ ‘，而是一个单一字符组成的字符串，a.split(‘该单一字符’)得到的列表为[‘’ for i in range(len(a)+1)]，而不是一个空列表。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        b = s.split()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> len(b) == <span class="number">0</span> <span class="keyword">else</span> len(b[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;给定一个仅包含大小写字母和空格&amp;apos; &amp;apos;的字符串，返回其最后一个单词的长度。如果不存在返回0
例子：
输入：&amp;apos;Hello World’
输出：5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个例子用python的str.split()很简单，只是想强调一下，当str为空或者全是’ ‘时，得到的列表也为空，此时不能用[-1]找最后一个元素。还有，如果a不为空或者全’ ‘，而是一个单一字符组成的字符串，a.split(‘该单一字符’)得到的列表为[‘’ for i in range(len(a)+1)]，而不是一个空列表。&lt;br&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="easy" scheme="http://yoursite.com/tags/easy/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 6 ZigZag变换</title>
    <link href="http://yoursite.com/2018/11/20/leetcode-6/"/>
    <id>http://yoursite.com/2018/11/20/leetcode-6/</id>
    <published>2018-11-20T13:52:08.000Z</published>
    <updated>2018-11-20T14:09:34.655Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><pre><code>将字符串’PAYPALISHIRING&apos;以Z字型排列成给定的行数，然后逐行读取字符：例子：行数为3P  A   H   NA P L S I I GY    I   R输出：&apos;PAHNAPLSIIGYIR&apos;</code></pre><p>例如第二行的，P L，他们是字符串的第3，5，此时row是2x3-2=4，那么可以看出 3 % 4 = 3， 5 % 4 = 1，3 + 1 = 4 = 2 <em> numrows -2 。他们都属于a[1],所以可以用2</em>numRows - 2 - row，来求出3的行数。<br><a id="more"></a> </p><pre><code class="python"><span class="comment">#python3</span><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s, numRows)</span>:</span>        <span class="string">"""</span><span class="string">        :type s: str</span><span class="string">        :type numRows: int</span><span class="string">        :rtype: str</span><span class="string">        """</span>        <span class="keyword">if</span> numRows == <span class="number">1</span>:            <span class="keyword">return</span> s        a = [<span class="string">''</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(numRows)] <span class="comment">#建立一个numrows的数组，用来存放每一行</span>        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):            row = i % (<span class="number">2</span>*numRows - <span class="number">2</span>)            <span class="keyword">if</span> row &gt;= numRows:                row = <span class="number">2</span>*numRows - <span class="number">2</span> - row <span class="comment">#！！！</span>            a[row] += s[i]        <span class="keyword">return</span> <span class="string">''</span>.join(a) <span class="comment">#a=[PAHN,APLSIIG,YIR]</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;将字符串’PAYPALISHIRING&amp;apos;以Z字型排列成给定的行数，然后逐行读取字符：
例子：
行数为3
P  A   H   N
A P L S I I G
Y    I   R
输出：
&amp;apos;PAHNAPLSIIGYIR&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如第二行的，P L，他们是字符串的第3，5，此时row是2x3-2=4，那么可以看出 3 % 4 = 3， 5 % 4 = 1，3 + 1 = 4 = 2 &lt;em&gt; numrows -2 。他们都属于a[1],所以可以用2&lt;/em&gt;numRows - 2 - row，来求出3的行数。&lt;br&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="medium" scheme="http://yoursite.com/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>python @装饰器</title>
    <link href="http://yoursite.com/2018/11/20/python-decorator/"/>
    <id>http://yoursite.com/2018/11/20/python-decorator/</id>
    <published>2018-11-20T09:08:11.000Z</published>
    <updated>2018-11-20T12:12:24.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><p>装饰器的用处是不需要大批量修改某函数就能实现为其增添功能。装饰器满足两点要求：  </p><ol><li>不能修改被装饰函数的源代码  </li><li>不能修改被装饰函数的调用方式  </li></ol><p>在讲解装饰器之前，我们还需要明白几个表达方式。对一个函数test1()来说：  </p><ol><li>test1表示的是函数的内存地址  </li><li>test1()就是在调用在test1这个地址的内容，也就是在调用函数  </li></ol><p>现在正式开始介绍装饰器的用法。<br><a id="more"></a> </p><h2 id="不带参数装饰器"><a href="#不带参数装饰器" class="headerlink" title="不带参数装饰器"></a>不带参数装饰器</h2><p>这里我们先假设我们有一个函数test，我们想在不改变函数代码和调用方式的前提下，实现对test的运行时间计算。<br>不使用装饰器的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">running_time</span><span class="params">()</span>:</span></span><br><span class="line">            print(<span class="string">'%s loaded'</span>%func)</span><br><span class="line">            start = time.time()</span><br><span class="line">            res = func()<span class="comment">#4</span></span><br><span class="line">            end = time.time()</span><br><span class="line">            print(<span class="string">'func running time is %s'</span>%(-start+end))</span><br><span class="line">            <span class="keyword">return</span> res <span class="comment">#6</span></span><br><span class="line">        <span class="keyword">return</span> running_time  <span class="comment">#2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span><span class="comment">#5</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'test is running'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'test finished'</span></span><br><span class="line"><span class="comment">#调用方式</span></span><br><span class="line">test = timer(test)<span class="comment">#1</span></span><br><span class="line">test()<span class="comment">#3</span></span><br></pre></td></tr></table></figure></p><p>上面的代码在最后两行调用的时候，我们先是把test作为内存地址传入timer，然后timer会执行#1，返回它的内嵌函数running_time的内存地址（注意不是调用），也就是说现在的test存的不再是test函数的内存地址，<br>而是running_time的内存地址，所以我们在#3调用test（）时，其实执行的是running_time，然后在running_time内部再调用test（），计算它的运行时间，大致的流程可以参考注释中的顺序。<br>它的输出如下：</p><pre><code>&lt;function test at 0x00C21A08&gt; loadedtest is runningfunc running time is 2.000366687774658test finished</code></pre><p>下面我们用@装饰器的语法来简化上述过程。只需要在被调用函数的前面加上@装饰器就可以了。最后函数的调用语句并没有改变（仍为test（）），这也完成了某种程度上对该函数的改写。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">running_time</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment">#1</span></span><br><span class="line">            print(<span class="string">'%s loaded'</span>%func)</span><br><span class="line">            start = time.time()</span><br><span class="line">            res = func(*args, **kwargs) <span class="comment">#2</span></span><br><span class="line">            end = time.time()</span><br><span class="line">            print(<span class="string">'func running time is %s'</span>%(-start+end))</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> running_time</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(parameters=None)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'test is running'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'test finished'</span></span><br><span class="line"> </span><br><span class="line">test()</span><br></pre></td></tr></table></figure></p><p>值得注意的是，被装饰的函数有时可能也有入参，那么我们可以在装饰器的内嵌函数的入参位置加上args和kwargs确保我们接受了全部的参数（见#1，#2），然后再传递给内嵌函数内对被装饰函数的调用处。<br>这段代码的输出和上一段一样。</p><h2 id="带参数装饰器"><a href="#带参数装饰器" class="headerlink" title="带参数装饰器"></a>带参数装饰器</h2><p>当我们有多个被装饰的函数时，我们可能需要在装饰器中将他们区分开来进行处理，这就需要@装饰器（parameter=value)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(parameter)</span>:</span> <span class="comment">#3</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inside_timer</span><span class="params">(func)</span>:</span> <span class="comment">#5</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">running_time</span><span class="params">()</span>:</span> <span class="comment">#7</span></span><br><span class="line">            print(<span class="string">'%s loaded'</span>%parameter)</span><br><span class="line">            start = time.time()</span><br><span class="line">            res = func() <span class="comment">#8</span></span><br><span class="line">            end = time.time()</span><br><span class="line">            print(<span class="string">'func running time is %s'</span>%(-start+end))</span><br><span class="line">            <span class="keyword">return</span> res  <span class="comment">#11</span></span><br><span class="line">        <span class="keyword">return</span> running_time <span class="comment">#6</span></span><br><span class="line">    <span class="keyword">return</span> inside_timer   <span class="comment">#4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(parameter='task1') #2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span> <span class="comment">#8</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'test is running'</span>) <span class="comment">#9 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'test finished'</span> <span class="comment">#10</span></span><br><span class="line">test() <span class="comment">#1</span></span><br></pre></td></tr></table></figure></p><p>输出是  </p><pre><code>task1 loaded  test is running  func running time is 2.000399112701416  test finished  </code></pre><p>如果我们不用装饰器这个语法，那么最后的调用过程为：</p><pre><code>timer=timer(parameter=value) #执行完毕后，timer存储的是inside_timer的内存地址test=timer(test)   #将test作为入参传入inside_timer，返回running_time的内存地址给testtest()    #这一步的执行过程和无参数的装饰器都一样</code></pre><h3 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h3><p>如果看完还有疑惑可以参考：<a href="http://lib.csdn.net/article/python/62942" target="_blank" rel="noopener">http://lib.csdn.net/article/python/62942</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;几个概念&quot;&gt;&lt;a href=&quot;#几个概念&quot; class=&quot;headerlink&quot; title=&quot;几个概念&quot;&gt;&lt;/a&gt;几个概念&lt;/h2&gt;&lt;p&gt;装饰器的用处是不需要大批量修改某函数就能实现为其增添功能。装饰器满足两点要求：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不能修改被装饰函数的源代码  &lt;/li&gt;
&lt;li&gt;不能修改被装饰函数的调用方式  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在讲解装饰器之前，我们还需要明白几个表达方式。对一个函数test1()来说：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;test1表示的是函数的内存地址  &lt;/li&gt;
&lt;li&gt;test1()就是在调用在test1这个地址的内容，也就是在调用函数  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在正式开始介绍装饰器的用法。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra 找最短路径</title>
    <link href="http://yoursite.com/2018/11/16/Dijkstra/"/>
    <id>http://yoursite.com/2018/11/16/Dijkstra/</id>
    <published>2018-11-16T14:43:54.000Z</published>
    <updated>2018-11-16T16:11:58.501Z</updated>
    
    <content type="html"><![CDATA[<p>寻找加权图G中src点到图中其他可抵达点的最短路径。我们用适应性强的优先队列去实现最小值提取，队列的选择有两种选择:<br>1.堆O((n+m)logn)<br>2.未排序的序列O(n^2)<br>当边的数量很少（m&lt;n^2/logn)用堆，反之序列。<br>下面的代码中我们用堆实现。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortest_path_lengths</span><span class="params">(g, src)</span>:</span></span><br><span class="line">    d = &#123;&#125; <span class="comment">#save the smallest weight from v to u</span></span><br><span class="line">    cloud = &#123;&#125; <span class="comment">#map reachable v to its d[v] value</span></span><br><span class="line">    pq = AdaptableHeapPriorityQueue() <span class="comment">#vertex v will have key d[v]</span></span><br><span class="line">    pqlocator = &#123;&#125; <span class="comment"># map from vertex to its pq locator </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#the source having distance 0 and the rest have infinite</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> g.vertices():</span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">is</span> scr:</span><br><span class="line">            d[v] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d[v] = float(inf)</span><br><span class="line">        pqlocator[v]=pq.add(d[v], v) <span class="comment">#save locator for future update</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> pq.is_empty():</span><br><span class="line">        key, u = pq.remove_min()</span><br><span class="line">        cloud[u] = key</span><br><span class="line">        <span class="keyword">del</span> pqlocator[u]</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> g.incident_edges(u):      <span class="comment">#incident_edges return a set of u's edges</span></span><br><span class="line">            v = e.opposite(u)    <span class="comment">#return the other side of the edge</span></span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> cloud:</span><br><span class="line">                wgt = e.element()        <span class="comment">#return the weight</span></span><br><span class="line">                <span class="keyword">if</span> d[u]+wgt &lt; d[v]:</span><br><span class="line">                    d[v] = d[u]+wgt      <span class="comment">#update the distance make sure it only gets smaller</span></span><br><span class="line">                    pq.update(pqlocator[v], d[v], v)</span><br><span class="line">    <span class="keyword">return</span> cloud        <span class="comment"># only include reachable vertices with shortest distance from src</span></span><br></pre></td></tr></table></figure></p><p>下面代码输出这个以src为源顶点的最小路径树。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortest_path_tree</span><span class="params">(g, s, cloud)</span>:</span></span><br><span class="line">    tree = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> cloud:</span><br><span class="line">        <span class="keyword">if</span> u <span class="keyword">is</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">for</span> e <span class="keyword">in</span> g.incident_edges(u, <span class="keyword">False</span>): <span class="comment">###!!!!the set of INCOMING edges！！！</span></span><br><span class="line">                v = e.opposite(u)</span><br><span class="line">                wgt = e.element()</span><br><span class="line">                <span class="keyword">if</span> wgt+cloud[v] == cloud[u]:   <span class="comment">###important step</span></span><br><span class="line">                    tree[u] = e</span><br><span class="line">    <span class="keyword">return</span> tree                                <span class="comment"># a dict(graph) of shortest edges</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;寻找加权图G中src点到图中其他可抵达点的最短路径。我们用适应性强的优先队列去实现最小值提取，队列的选择有两种选择:&lt;br&gt;1.堆O((n+m)logn)&lt;br&gt;2.未排序的序列O(n^2)&lt;br&gt;当边的数量很少（m&amp;lt;n^2/logn)用堆，反之序列。&lt;br&gt;下面的代码中我们用堆实现。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="加权图" scheme="http://yoursite.com/tags/%E5%8A%A0%E6%9D%83%E5%9B%BE/"/>
    
      <category term="最短路径" scheme="http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>可适应性优先级队列（基于堆）</title>
    <link href="http://yoursite.com/2018/11/16/AdaptableHeapPriorityQueue/"/>
    <id>http://yoursite.com/2018/11/16/AdaptableHeapPriorityQueue/</id>
    <published>2018-11-16T13:31:40.000Z</published>
    <updated>2018-11-16T14:52:07.742Z</updated>
    
    <content type="html"><![CDATA[<p>由于传统的堆并不支持对堆中除头和尾以外的位置的增删改，而在实际情况下我们需要对其他节点进行操作。这里我们在堆原有数据结构基础上进行扩展，<br>用’定位器‘来实现对堆中其他元素的定位。定位器是指在堆原有节点类中加入一个新属性_index（节点在底层数据结构数组中的秩），然后实列化节点类（locator），<br>并返回给用户用来定位每一个节点。<br><a id="more"></a><br>下面我们先展示基于原始堆的优先级排序数据结构的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapPriorityQueue</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">_Item</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">            self._key = key</span><br><span class="line">            self._val = value</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self._key &lt; other._key</span><br><span class="line"><span class="comment">### private behaviours</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_left</span><span class="params">(self, j)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*j+<span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_right</span><span class="params">(self, j)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*j+<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_parent</span><span class="params">(self, j)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (j<span class="number">-1</span>)//<span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_has_left</span><span class="params">(self, j)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._left(j) &lt; len(self._data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_has_right</span><span class="params">(self, j)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._right(j) &lt; len(self._data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_swap</span><span class="params">(self, i, j)</span>:</span>        </span><br><span class="line">        self._data[i], self._data[j] = self._data[j], self._data[i]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_downheap</span><span class="params">(self, j)</span>:</span>   <span class="comment">#向下冒泡</span></span><br><span class="line">        <span class="keyword">if</span> self._has_right(j):</span><br><span class="line">            small = self._right(j)</span><br><span class="line">            <span class="keyword">if</span> self._has_left(j):</span><br><span class="line">                <span class="keyword">if</span> self._data[self._left(j)] &lt; self._data[small]:</span><br><span class="line">                    small = self._left(j)</span><br><span class="line">            <span class="keyword">if</span> self._data[small] &lt; self._data[j]:</span><br><span class="line">                self._swap(small, j)</span><br><span class="line">                self._downheap(small)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_upheap</span><span class="params">(self, j)</span>:</span>   <span class="comment">#向上冒泡</span></span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> self._data[j] &lt; self._data[self._parent(j)]:</span><br><span class="line">            self._swap(j, self._parent(j))</span><br><span class="line">            self._upheap(self._parent(j)) </span><br><span class="line"><span class="comment">###public behaviours</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._data = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self)==<span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, k, v)</span>:</span></span><br><span class="line">        self._data.append(self._Item(k,v))</span><br><span class="line">        self._upheap(len(self._data)<span class="number">-1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'heap is empty'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._data[<span class="number">0</span>]._key, self._data[<span class="number">0</span>].val</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> ValueError</span><br><span class="line">        self._swap(<span class="number">0</span>, len(self._data)<span class="number">-1</span>)</span><br><span class="line">        item = self._data.pop()</span><br><span class="line">        self._downheap(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (item._key, item._val)</span><br></pre></td></tr></table></figure></p><p>接下来是适应性优先级队列，对于这个我们提供两种新方法：update（更新堆中某一节点），remove（删除某一节点）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdapatablePriorityHeapQueue</span><span class="params">(HeapPriorityQueue)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Locator</span><span class="params">(HeapProrityQueue._Item)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k, v, index)</span>:</span></span><br><span class="line">            super().__init__(k,v)</span><br><span class="line">            self._index = index</span><br><span class="line"><span class="comment">### private behaviours    </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_swap</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        super()._swap(i, j)</span><br><span class="line">        self._data[i]._index = i</span><br><span class="line">        self._data[j]._index = j</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_bubble</span><span class="params">(self, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;j <span class="keyword">and</span> self._data[j] &lt; self._data[self._parent(j)]:</span><br><span class="line">            self._upheap(j)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._downheap(j)</span><br><span class="line"><span class="comment">### public behaviours</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, k, v)</span>:</span></span><br><span class="line">        loc = self.Locator(k, v, len(self))</span><br><span class="line">        self._data.append(loc)</span><br><span class="line">        self._upheap(len(self._data)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> loc</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, loc, k, v)</span>:</span></span><br><span class="line">        j = loc._index</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span>&lt;=j&lt;len(self)) <span class="keyword">and</span> self._data[j]==loc:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'invalid locator'</span>)</span><br><span class="line">        loc._key = k</span><br><span class="line">        loc._val = v</span><br><span class="line">        <span class="keyword">return</span> loc</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, loc)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> ValueError</span><br><span class="line">        j = loc._index</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span>&lt;=j&lt;len(self)) <span class="keyword">and</span> self._data[j]==loc:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'invalid locator'</span>)</span><br><span class="line">        <span class="keyword">if</span> j != len(self)<span class="number">-1</span>:</span><br><span class="line">            self._swap(j, len(self)<span class="number">-1</span>)</span><br><span class="line">            self._bubble(j)</span><br><span class="line">        self._data.pop()</span><br><span class="line">        <span class="keyword">return</span> (loc._key, loc._val)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于传统的堆并不支持对堆中除头和尾以外的位置的增删改，而在实际情况下我们需要对其他节点进行操作。这里我们在堆原有数据结构基础上进行扩展，&lt;br&gt;用’定位器‘来实现对堆中其他元素的定位。定位器是指在堆原有节点类中加入一个新属性_index（节点在底层数据结构数组中的秩），然后实列化节点类（locator），&lt;br&gt;并返回给用户用来定位每一个节点。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 25 k个一组反转链表</title>
    <link href="http://yoursite.com/2018/11/16/leetcode-25/"/>
    <id>http://yoursite.com/2018/11/16/leetcode-25/</id>
    <published>2018-11-16T04:23:49.000Z</published>
    <updated>2018-11-16T05:01:00.982Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><pre><code>给出一个链表，每k个一组进行翻转，并返回翻转后的链表。如果节点总数不是k的整数倍，那么将剩余节点保持原序返回。例子：    给出：1-&gt;2-&gt;3-&gt;4-&gt;5, k=3    输出：3-&gt;2-&gt;1-&gt;4-&gt;5说明：    1. 你的算法只能使用常数的额外空间    2. 不能单纯的改变节点的值，需要对实际节点进行交换</code></pre><p>首先要判断链表长度是否大于k，然后再进行分组翻转。由于会有剩余部分，不要忽略翻转完毕后对剩余部分的重新连接。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python 3</span></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        start = head</span><br><span class="line">        pre = cur = new = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            head = head.next</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; length: <span class="keyword">return</span> start  <span class="comment">#!!!start is the original head, head already move to NULL!!!</span></span><br><span class="line">        t = length // k</span><br><span class="line">        <span class="keyword">while</span> t &gt; <span class="number">0</span>:</span><br><span class="line">            cur, new = self.reverse(start, k)</span><br><span class="line">            <span class="keyword">if</span> pre <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                res = cur <span class="comment">#!!!cur is the new head not start!!!</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.next = cur</span><br><span class="line">            pre = start</span><br><span class="line">            start = new</span><br><span class="line">            t -= <span class="number">1</span></span><br><span class="line">        pre.next = start <span class="comment">#!!!do not forget to connect the rest of the list!!!</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, start, k)</span>:</span></span><br><span class="line">        cur, pre = start, <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            temp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = temp</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> pre, cur</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;给出一个链表，每k个一组进行翻转，并返回翻转后的链表。
如果节点总数不是k的整数倍，那么将剩余节点保持原序返回。
例子：
    给出：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, k=3
    输出：3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5
说明：
    1. 你的算法只能使用常数的额外空间
    2. 不能单纯的改变节点的值，需要对实际节点进行交换
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先要判断链表长度是否大于k，然后再进行分组翻转。由于会有剩余部分，不要忽略翻转完毕后对剩余部分的重新连接。&lt;br&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="hard" scheme="http://yoursite.com/tags/hard/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 92 反转m到n的链表</title>
    <link href="http://yoursite.com/2018/11/14/leetcode-92/"/>
    <id>http://yoursite.com/2018/11/14/leetcode-92/</id>
    <published>2018-11-14T15:47:01.000Z</published>
    <updated>2018-11-16T05:00:58.834Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><pre><code>反转从位置m到n的链表。请使用一趟扫描完成反转。(1&lt;=m&lt;=n&lt;=lenofthelist)例子:    input：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m=2, n=4    output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL    </code></pre><p>首先记录m-1的节点(front)，然后依次倒置[m,n]之间的节点，期间还要注意m节点的收藏(tail)，用来设置tail.next=back，然后记录n+1(back)节点，最后完成n+1，m-1连接。由于倒置是通过不停的选择next节点来完成，为了防止陷入死循环，本次节点(cur)与本次节点next节点(temp)的关系倒置要放到下一次循环中处理，这就需要我们引入pre来记录本次节点。<br>简而言之，介于[m,n]间的单次循环要完成两项任务：1. 设置temp 2. 完成cur.next = pre。<br>另外，几个需要注意的小细节，这里的m,n指的是位置，不是类似于数组的秩，是从1开始的。所以在循环倒置时，i也应先加1，表示此次是对第一个位置操作。<br><a href="https://leetcode.com/problems/reverse-linked-list-ii/discuss/184849/Python-Solution-20ms-beats-100?from=singlemessage&amp;isappinstalled=0" target="_blank" rel="noopener">代码来源</a><br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        cur = head</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        back = tail = front = pre = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> i &lt; n+<span class="number">1</span>:</span><br><span class="line">            i += <span class="number">1</span>             </span><br><span class="line">            <span class="keyword">if</span> m &lt;= i &lt;= n:</span><br><span class="line">                tmp = cur.next <span class="comment">#task 1</span></span><br><span class="line">                <span class="keyword">if</span> pre <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                    tail = cur <span class="comment">#record m</span></span><br><span class="line">                cur.next = pre <span class="comment">#task 2</span></span><br><span class="line">                pre = cur</span><br><span class="line">                cur = tmp</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i == m<span class="number">-1</span>:</span><br><span class="line">                    front = cur <span class="comment">#record m-1</span></span><br><span class="line">                <span class="keyword">elif</span> i == n+<span class="number">1</span>:</span><br><span class="line">                    back = cur</span><br><span class="line">                cur = cur.next <span class="comment"># !!move to the next!!</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> front:</span><br><span class="line">            front.next = pre</span><br><span class="line">            res = head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = pre</span><br><span class="line">        tail.next = back</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;反转从位置m到n的链表。请使用一趟扫描完成反转。(1&amp;lt;=m&amp;lt;=n&amp;lt;=lenofthelist)
例子:
    input：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m=2, n=4
    output: 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先记录m-1的节点(front)，然后依次倒置[m,n]之间的节点，期间还要注意m节点的收藏(tail)，用来设置tail.next=back，然后记录n+1(back)节点，最后完成n+1，m-1连接。由于倒置是通过不停的选择next节点来完成，为了防止陷入死循环，本次节点(cur)与本次节点next节点(temp)的关系倒置要放到下一次循环中处理，这就需要我们引入pre来记录本次节点。&lt;br&gt;简而言之，介于[m,n]间的单次循环要完成两项任务：1. 设置temp 2. 完成cur.next = pre。&lt;br&gt;另外，几个需要注意的小细节，这里的m,n指的是位置，不是类似于数组的秩，是从1开始的。所以在循环倒置时，i也应先加1，表示此次是对第一个位置操作。&lt;br&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list-ii/discuss/184849/Python-Solution-20ms-beats-100?from=singlemessage&amp;amp;isappinstalled=0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;代码来源&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="medium" scheme="http://yoursite.com/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>HEXO部署到GitHub.io搭建个人博客</title>
    <link href="http://yoursite.com/2018/11/13/HEXO%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2018/11/13/HEXO部署/</id>
    <published>2018-11-13T12:07:42.000Z</published>
    <updated>2018-11-14T17:06:18.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="install-git"><a href="#install-git" class="headerlink" title="install git"></a><a href="https://github.com/funcab/notes/blob/master/git/usage.md" target="_blank" rel="noopener">install git</a></h2><h2 id="install-Node-js"><a href="#install-Node-js" class="headerlink" title="install Node.js"></a>install Node.js</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure><p>Close and reopen your terminal to start using nvm or run the following to use it now:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install stable</span><br></pre></td></tr></table></figure><a id="more"></a> <h2 id="install-Hexo-and-init"><a href="#install-Hexo-and-init" class="headerlink" title="install Hexo and init"></a>install Hexo and init</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">mkdir &lt;folder&gt;</span><br><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="install-NexT"><a href="#install-NexT" class="headerlink" title="install NexT"></a>install NexT</h2><p>Download latest release version:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir themes/next</span><br><span class="line">curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url </span><br><span class="line">| cut -d &apos;&quot;&apos; -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1</span><br></pre></td></tr></table></figure></p><p>Set theme in main hexo root config _config.yml file:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></p><h2 id="github-pages"><a href="#github-pages" class="headerlink" title="github pages"></a>github pages</h2><p>install plugins:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>edit <folder>/_config.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://[github用户名]:[github密码]@github.com/xxx/xxx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></folder></p><p>push to github：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure></p><p>publish new blog:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &apos;blogname&apos;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;install-git&quot;&gt;&lt;a href=&quot;#install-git&quot; class=&quot;headerlink&quot; title=&quot;install git&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/funcab/notes/blob/master/git/usage.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;install git&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;install-Node-js&quot;&gt;&lt;a href=&quot;#install-Node-js&quot; class=&quot;headerlink&quot; title=&quot;install Node.js&quot;&gt;&lt;/a&gt;install Node.js&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Close and reopen your terminal to start using nvm or run the following to use it now:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export NVM_DIR=&amp;quot;$HOME/.nvm&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[ -s &amp;quot;$NVM_DIR/nvm.sh&amp;quot; ] &amp;amp;&amp;amp; \. &amp;quot;$NVM_DIR/nvm.sh&amp;quot;  # This loads nvm&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nvm install stable&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="HEXO" scheme="http://yoursite.com/tags/HEXO/"/>
    
      <category term="搭建个人博客" scheme="http://yoursite.com/tags/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
